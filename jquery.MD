# Kako preživeti jQuery?
## Vodič za refaktorisanje Javaskript koda

Ukoliko ste ikad radili kao Front-end developer, verovatno ste naišli na ogroman `Javascript/jQuery` fajl (obično `main.js`), koji su pisale generacije developera, ko je kako stigao. Novi developeri obično ubace svoje parče koda na dnu fajla, bez neke posebne logike. Takav fajl brzo naraste na par stotina (čak par hiljada) linija, pa je veoma teško izboriti se sa njim.

`jQuery` je nastao kao pomoćno sredstvo za manipulaciju `DOM`-a, nije predviđen za ogromne front-end aplikacije koje su u međuvremenu nastale. Ako se pažljivo ne organizuje, jQuery ima tendenciju da na velikim projektima postane haotičan.

Srećom, postoje rutinski koraci koji će vam pomoći da sve to organizujete. Nakon refaktorisanja, stara i neodrživa aplikacija će moći da nastavi razvoj, a `JavaSkript` kod će biti moguće odvojiti u zasebne module i prevesti u ES6.

## Sadržaj
  * [Postavite sktrukturu stranice](#postavite-sktrukturu-stranice)
  * [Organizujte varijable u posebnu sekciju](#organizujte-varijable-u-posebnu-sekciju)
  * [Organizujte event listenere u posebnu sekciju](#organizujte-event-listenere-u-posebnu-sekciju)
  * [Organizujte funkcije u posebnu sekciju](#organizujte-funkcije-u-posebnu-sekciju)
  * [Imenujte anonimne parametarske objekte](#imenujte-anonimne-parametarske-objekte)

## Postavite sktrukturu stranice

Za početak, komentarima naznačite glavne odeljke koje ćemo imati na stranici. Možda neki nisu ni potrebni, ali korisno je napraviti mini sadržaj na početku kao putokaz:

```javascript
/*** KONFIG ***/

/*** LISTENERS ***/

/*** FUNCTIONS ***/
```

Na početku su (globalne) varijable, koje služe kao konfiguracija. Potom dolaze event listeneri, unutar kojih se dešava logika i pozivaju funkcije. Na dnu se nalaze deklaracije funkcija, koje je moguće ranije koristiti zbog [*dizanja*] (http://www.w3schools.com/js/js_hoisting.asp). Neke od opštekorisnih funkcija kasnije možemo odvojiti u poseban fajl (npr. `utils.js`), izolovati iz globalnog opsega i organizovati kao modul.

Da biste stekli širu sliku, zamišljajte gornji deo fajla kao kontrolnu tablu, gde podešavate neke dugmiće, a donji deo kao unutrašnjost mašine. Sve dok radi, unutrašnjost mašine ne treba da vam bude pred očima. Kad neki deo otkaže, otvarate ga. Tako je i sa funkcijama (modulima). Ne treba sve vreme da vam budu pred očima.

<img src='https://upload.wikimedia.org/wikipedia/commons/0/09/Plc_control_panel.JPG' width='400'>

## Organizujte varijable u posebnu sekciju

Pretražite čitav fajl (ključna reč `var`) i gde god nađete varijablu u globalnom prostoru, premestite je u uvodnu sekciju. Izuzetak su varijable koje zavise od DOM-a, njih stavite unutar `document ready` eventa.

Ukoliko primetite da neke varijable ne treba da budu globalne nego lokalne, smestite ih u odgovarajući opseg. Ukoliko vidite da se neke od promenljivih zapravo koriste kao konstante, naznačite to `VELIKIM_SLOVIMA` u nazivu.

Ukoliko nađete [anonimne parametarske objekte](#imenujte-anonimne-parametarske-objekte), koji se prosleđuju funkcijama, imenujte ih i premestite u uvodnu sekciju. Tako ćemo imati sve konfiguracije na jednom mestu.

```javascript
/*** KONFIG ***/

var title = 'Refactoring jQuery';
var currentSpeed = 0;
var MAX_SPEED = 256;
var $table; // sada samo proglašavamo, a vrednost dodajemo kasnije, kada DOM bude spreman

```

## Organizujte event listenere u posebnu sekciju

Glavni jQuery slušalac događaja je `document ready`, koji se okida kada je HTML učitan (bez slika i svega ostalog što učitava iz HTML-a). Ovaj event vam garantuje da će u trenutku izvršenja Javaskripta u DOM-u biti prisutni svi oni elementi koje ciljamo.

Niži event listeneri obično idu unutar njega. Ako ih ostavimo izvan rizikujemo da DOM koji ciljaju još nije spreman. Listeneri koji se kače na globalne objekte (`document` ili `window`) mogu ići zasebno, jer su oni nezavisni.


```javascript
/*** LISTENERS ***/

$(document).ready(function() {

    $table = $('#table');

    $('.should-hide').click(function(){
        $(this).hide();
    });

    $('.book-description').click(function() {
      $('.book').fadeIn('slow');
    });

});


$(window).resize(function() {
  resizeThePage();
});
```

Ako ne želimo da gomilamo listenere u `document ready`, jQuery omogućuje da vežemo događaj za element koji još uvek ne postoji. Ako na primer hoćemo da vežemo klik event za klasu `.should-hide`, koja trenutno ne postoji u HTML-u:

```javascript
$('.should-hide').on('click', function() {
  $(this).hide();
});
```

Čak ni nakon što ciljana klasa bude dodata u DOM, klik neće raditi. Međutim, ako vežemo klik za globalni `document` objekat, kad on bude kliknut delegiraće klik potčinjenoj klasi ukoliko se ona u međuvremenu pojavi:

```javascript
$(document).on('click', '.should-hide', function(){
	$(this).hide();
});
```

## Organizujte funkcije u posebnu sekciju

Pretražite fajl i organizujte sve funkcije u posebnu sekciju, koja se nalazi na dnu. Anonimne funkcije za sada ostavite gde jesu, ali ćemo i neke od njih kasnije odvojiti. Sada naš odeljak sa funkcijama izgleda ovako:

```javascript
/*** FUNCTIONS ***/

function toCelsius(fahrenheit) {
    return (5/9) * (fahrenheit-32);
}

function toDegrees (angle) {
  return angle * (180 / Math.PI);
}

function toRadians (angle) {
  return angle * (Math.PI / 180);
}
```

Tokom ovog procesa, verovatno ćete morati da popravite neke funkcije. Vodite računa da svaka funkcija obavlja jedan zadatak i da ima jasno definisan ulaz i izlaz (ukoliko treba nešto da vrati). Nemojte da funkcija podrazumeva dostupnost bilo čega, osim onog što joj je prosleđeno. Imajte na umu da kad premestite funkciju u drugi kontekst ona treba i dalje da radi.

## Imenujte anonimne funkcije

Imenovanje anonimnih funkcija je važan korak kako bismo izbegli zloglasni [*callback pakao*](http://callbackhell.com/). Evo primera zbrkanog koda, kojim JavaScript iz browsera šalje http zahtev serveru (preuzet sa *callbackhell* sajta):

```javascript
var form = document.querySelector('form')
form.onsubmit = function (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: 'http://example.com/upload',
    body: name,
    method: 'POST'
  }, function (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}
```

U kodu postoje dve anonimne funkcije. Hajde da ih imenujemo:

```javascript
var form = document.querySelector('form')
form.onsubmit = function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: 'http://example.com/upload',
    body: name,
    method: 'POST'
  }, function postResponse (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}
```

Kao što vidite, imenovanje funkcija je veoma lako i ima brojne prednosti:
* čini kod čitljivijim zahvaljujući opisnim nazivima funkcija
* omogućuje nam da pomerimo funkciju u zasebnu sekciju
* ako dođe do greške prijaviće nam aktuelnu funkciju, umesto anonimne

Sada naša skripta za slanje formulara izgleda ovako:

```javascript
document.querySelector('form').onsubmit = formSubmit;

function formSubmit (e) {
  var name = document.querySelector('input').value
  request({
    uri: 'http://example.com/upload',
    body: name,
    method: 'POST'
  }, postResponse)
}

function postResponse (err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}
```

Imenovanje anonimnih funkcija je često korisno, ali ne uvek. Funkcije nekada treba da ostanu anonimne, ali to treba eksplicirati tako što ćemo ih prevesti u [streličaste funkcije](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions).

Gornji kod možemo još dodatno refaktorisati imenovanjem anonimnog parametarskog objekta, o čemu u narednom odeljku.

## Imenujte anonimne parametarske objekte

```javascript
function formSubmit (e) {
  var name = document.querySelector('input').value
  request({
    uri: 'http://example.com/upload',
    body: name,
    method: 'POST'
  }, postResponse)
}
```

```javascript
var postParams = {
  uri: 'http://example.com/upload',
  body: name,
  method: 'POST'
}

function formSubmit(e) {
  var name = document.querySelector('input').value
  request(postParams, postResponse)
}
```

## Uklonite sav JavaScript iz HTML-a

Često kolege ubacuju male pomoćne skripte u HTML kako bi postigli neku funkcionalnost na određenoj stranici.

```html
<script>
	// Any global variable set-up that might be needed.
	$(document).ready(initPage);
	doThis();
	dontDoThat();
</script>
```

Uklonite sav JS iz HTML-a u posebne fajlove nazvane po stranici sa koje su uklonjeni (npr. `contact.js` ili `products.js`) i učitajte ih regularnim putem. Između ostalog, ovo će nam omogućiti da imamo svu funkcionalnost na jednom mestu, da ne mešamo više jezika u jednom fajlu, da asinhrono učitavamo skripte i da postepeno pređemo na modularnu arhitekturu.

Pored velikih JS blokova koji se nalaze unutar `script` tagova, često imate i *inline* pozive JS funkcija. Uklonite i sve to, iz gore navedenih razloga. Dakle, ako ste imali:

```html
<div onclick='showMore()'>Show more!</a>
```

Umesto toga ostavite `CSS` klasu koju će vaš Javaskript ciljati. Pošto osnovna namena te klase nije stilizovanje, eksplicirajte to u njenom nazivu. Možete smisliti bilo koju konvenciju, ja predlažem `js-` ispred naziva klase:

```html
<div class='js-show-more'>Show more!</a>
```

```javascript
$('.doSomething').click(showMore);
```

## Podelite kod u zasebne fajlove

![alt text](http://i.stack.imgur.com/YaaJ6.png)

Podelite glavni Javaskript fajl u zasebne fajlove, nazvane po logičkim celinama za čiju funkcionalnost su zaduženi (npr. `contact.js`, `header.js`, `slider.js`). U glavnom fajlu ostavite samo zajedničku funkcionalnost.

Podela briga će nam olakšati razvoj i smanjiti vreme učitavanja, jer ćemo skripte specifične za neku stranicu učitavati samo na toj stranici. Zajedno sa drugim koracima, ovo će nam pomoći da pređemo na modularnu organizaciju projekta.

## Lokalizujte globalne varijable

Ceo Javaskript fajl ćemo lako lokalizovati tako što ćemo ga zatvoriti u [closure](https://developer.mozilla.org/en/docs/Web/JavaScript/Closures), odnosno u [samoizvršujuću anonimnu funkciju](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression):

```javascript
(function() {
    // jQuery je ovde dostupan pod alijasom $
})();
```

Na ovaj način, sve što je ostalo unutra više nije dostupno za spoljni svet. Ako nam je nešto ipak potrebno, moramo to izvesti van:

```javascript
var DED = (function() {

    var private_var;

    function private_method()
    {
        // do stuff here
    }

    return {
        method_1 : function()
            {
                // do stuff here
            },
        method_2 : function()
            {
                // do stuff here
            }
    };
})();
```

Ukoliko vaš modul ima neku spoljašnju zavisnost (u ovom slučaju sigurno jQuery, onda to eksplicirajte:

```javascript
(function($) {
    // jQuery je ovde dostupan pod alijasom $
})(jQuery);
```

Ovako prosleđujemo globalnu `jQuery` varijablu našem modulu, koju unutra koristimo pod alijasom `$`. Globalna varijabla će naravno biti dostupna i ako je ne prosledimo, ali ovako ekspliciramo zavisnost modula u slučaju da promeni okruženje.

## Učitavajte skripte asinhrono

![asinhrono učitavanje modula](https://upload.wikimedia.org/wikipedia/commons/2/22/Asynchronous_Module_Definition_overview_vector.svg 'Razlika između blokirajućeg i asinhronog učitavanja JS modula')

Asinhrono učitavanje skripti je jedino ispravno rešenje koje [Google preporučuje](https://developers.google.com/speed/docs/insights/BlockingJS). Skripte se na taj način učitavaju istovremeno, umesto jedna za drugom, ali se takođe izvršavaju bez ikakvog reda, što može biti malo nezgodno.

Postoji gomila rešenja koje regulišu [učitavanje](https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import) modula (npr. RequireJS, CommonJS, Webpack...), a možete sve to rešiti i ručno. [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) alatke nam omogućuju da eksplicitno navedemo od kojih biblioteka naša skripta zavisi, pa se kod izvršava tek kad se zavisnosti učitaju (npr. ako je za skriptu neophodan jQuery, izvršiće se nakon što se jQuery učita).

## Organizujte povezane varijable u objekte

http://12devsofxmas.co.uk/2014/01/day-8-architecting-your-front-end-javascript/

A typical JavaScript file might be strewn with global variables and methods:
```javascript
var height = 20;
var width = 50;
var x = 0;
var moveToNextItem = function() { /* snip */ }
var startAccordion = function() { /* snip */ }
```

incredibly difficult to tell what’s going on, which functions affect which variables and which code is related, and which are entirely different parts of your app. Objects can help:

```javascript
var accordion = {
    currentItem: 1,
    domElem: $('#accordion'),
    startAccordion: function() { /* snip */ },
    isAtEnd: function() { /* snip */ }
    // and so on
};

var carousel = {
    currentItem: 1,
    domElem: $('#carousel'),
    transition: function() { /* snip */ }
    // and so on
};
```

Immediately, with very little extra typing or effort, code is nicely contained, and it becomes easily apparent what each part of the code does.

## Smestite selektore u varijable

Ukoliko često hvatate određene elemente na stranici, na primer linkove, nemojte ih selektovati svaki put:
```javascript
$('a').click(function(){
    $('a').addClass('wow');
});
```

Umesto toga ih jednom uhvatite i smestite u varijablu (keširajte), čime ćete blago optimizovati kod:

```javascript
var $a = $('a');
$a.click(function(){
    $a.addClass('wow');
});
```

Primećujete da `$` u nazivu varijable koristimo da naznačimo da je u pitanju jQuery objekat, a ne bilo kakva promenljiva, što je [*de facto* standard](http://lab.abhinayrathore.com/jquery-standards/).

## Korisni linkovi
http://stackoverflow.com/questions/16736483/best-way-to-organize-jquery-javascript-code-2013
